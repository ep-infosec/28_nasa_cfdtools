C***** DTGET *****
C   GET BASIC PARAMETERS FROM SPLINE ARRAY, CHECKING FOR BAD VALUES
C     IN A WAY WHICH WILL NOT CAUSE AN ABORT.  OPTIONALLY CHECK THE
C     LEGITIMACY OF THE KNOT VECTORS.  RETURNS IER VALUE TO CALLER,
C     BUT NEVER PRINTS ANY MESSAGE OR TAKES ANY OTHER ACTION CONNECTED
C     WITH ERRORS.  STOPS EXTRACTING DATA AS SOON AS AN ERROR IS
C     DETECTED.
C
C   INPUT:
C     C       SPLINE ARRAY.
C     FULCHK  REQUESTS KNOT VECTOR CHECK WHEN .TRUE.
C     NMAX    SIZE OF OUPUT ARRAYS SUPPLIED.  NO ERROR REPORTED
C             WHEN SMALLER THAN N, BUT ONLY SUPPLIES DATA FOR FIRST 
C             MIN (NMAX, N) INDEPENDENT VARIABLES.  CALLING ROUTINE
C             IS EXPECTED TO CHECK WHETHER N IS LEGITIMATE.
C   OUTPUT:
C     N       NUMBER OF INDEPENDENT VARIABLES (VALUE OF C(1))
C     MRAW    VALUE OF C(2).  NEGATIVE INDICATES RATIONAL SPLINE.
C             ABSOLUTE VALUE INDICATES NUMBER OF COEFFICIENT ARRAYS.
C     M       NUMBER OF DEPENDENT VARIABLES.  EQUALS MRAW IF MRAW IS
C             NONNEGATIVE, -MRAW-1 IF MRAW IS NEGATIVE.
C     K()     ARRAY OF SPLINE ORDERS (BY INDEPENDENT VARIABLE)
C     NCOEF() ARRAY OF INDEX BOUNDS FOR THE COEFFICIENT ARRAY (TENSOR), 
C             WHICH ARE THE NUMBERS OF B-SPLINE BASIS FUNCTIONS (BY 
C             INDEPENDENT VARIABLE) FOR EACH COMPONENT OF THE TENSOR 
C             PRODUCT BASIS.
C     PLO()   PARAMETER LOW VALUES (BY INDEPENDENT VARIABLE)
C     PHI()   PARAMETER HIGH VALUES (BY INDEPENDENT VARIABLE)
C     IER     ERROR FLAG.  ZERO MEANS GOOD DATA.
C
C   CALLS:
C      DTMCON
C*****
      SUBROUTINE DTGET (C, FULCHK, NMAX, N, MRAW, M, K, NCOEF, PLO, 
     +    PHI, IER)
      LOGICAL FULCHK
      INTEGER NMAX, N, MRAW, M, K(NMAX), NCOEF(NMAX), IER
      DOUBLE PRECISION C(*), PLO(NMAX), PHI(NMAX)
C
C   LOCAL VARIABLES:
      DOUBLE PRECISION BIGINT, DTMCON
      INTEGER I, J, JN, L, LK, LKK, LKN, NN
C
C   INITIALIZATION:
      IER = 0
      BIGINT = DTMCON(11)
C
C   GET N
      IF (C(1) .LT. 1.0D0 .OR. C(1) .GT. BIGINT) GO TO 9901
      N = INT(C(1))
      NN = MIN (N, NMAX)
C
C   GET MRAW AND M
      IF (ABS(C(2)) .GT. BIGINT) GO TO 9902
      MRAW = INT(C(2))
      M = MRAW
      IF (MRAW .LT. 0) M = -MRAW - 1
      IF (M .EQ. 0) GO TO 9902
C
C   LOOP THROUGH DATA FOR FIRST NN INDEPENDENT VARIABLES
      L = 3
      LK = 3 * N + 2
      DO 100 I=1,NN
C
C     GET K()
        IF (C(L) .LT. 1.0D0 .OR. C(L) .GT. BIGINT) GO TO 9903
        K(I) = INT(C(L))
C
C     GET NCOEF()
        IF (C(L+N) .LT. C(L) .OR. C(L+N) .GT. BIGINT) GO TO 9904
        NCOEF(I) = INT(C(L+N))
C
        LKK = LK + K(I)
        LKN = LK + NCOEF(I)
        IF (FULCHK) THEN
C         DO FULL CHECK ON KNOT SEQUENCE
          IF (K(I) .GT.1) THEN
C           CONFIRM ORDER K KNOT ON EACH END
            JN = LKN + 2
            DO 10 J=LK+2,LKK
              IF (C(J) .NE. C(J-1)) GO TO 9905
              IF (C(JN) .NE. C(JN-1)) GO TO 9905
              JN = JN + 1
  10        CONTINUE
          END IF
C         CONFIRM ORDER OF FIRST KNOT NO MORE THAN K
          IF (C(LKK) .GE. C(LKK+1)) GO TO 9905
          IF (NCOEF(I) .GT. K(I)) THEN
C           CHECK INTERIOR KNOTS IN ASCENDING SEQUENCE AND OF ORDER <= K
            DO 20 J=LKK+1,LKN
              IF (C(J) .GT. C(J+1)) GO TO 9905
              IF (C(J) .GE. C(J+K(I))) GO TO 9905
  20        CONTINUE
            IF (C(LKN) .GE. C(LKN+1)) GO TO 9905
          END IF
        END IF
C
C     GET PARAMETER INTERVAL
        PLO(I) = C(LKK)
        PHI(I) = C(LKN+1)
C
        L = L+1
        LK = LK + K(I) + NCOEF(I)
 100  CONTINUE
      RETURN
C
C   ERROR EXITS
C   BAD N 
 9901 IER = -1
      RETURN
C   BAD MRAW (AND M)
 9902 IER = -2
      RETURN
C   BAD K()
 9903 IER = -3
      RETURN
C   BAD NCOEF()
 9904 IER = -4
      RETURN
C   BAD KNOT VECTOR
 9905 IER = -5
      RETURN
      END
