      SUBROUTINE DTDIGL (XLB, XUB, YLBCON, YLB, FUNYLB, YUBCON, YUB,
     +    FUNYUB, FUNXY, PARM1, PARM2, PARM3, ERRTOL, MAXCYC, 
     +    RESULT, ERREST, IER)

C   COMPUTE DOUBLE INTEGRAL
C     COMPUTE THE DOUBLE INTEGRAL OF A USER-SUPPLIED FUNCTION OF
C     TWO VARIABLES OVER A REGION WHOSE BOUNDARY LIMITS MAY BE EITHER
C     CONSTANT OR COMPUTED FROM USER-SUPPLIED FUNCTIONS OF ONE OF THE
C     VARIABLES.
C
C     DOES AN ITERATED INTEGRAL USING AN ADAPTIVE LEGENDRE-GAUSS
C     QUADRATURE PROCESS IN EACH SINGLE INTEGRATION.  MODELED ON THE
C     SINGLE INTEGRAL ROUTINE DTQUAD.
C
C   INPUT:
C     XLB     LOWER BOUND FOR VARIABLE (X) USED IN OUTER INTEGRAL.
C     XUB     UPPER BOUND FOR VARIABLE (X) USED IN OUTER INTEGRAL.
C     YLBCON  CONTROLS COMPUTATION OF LOWER BOUND FOR VARIABLE (Y) USED
C             IN INNER INTEGRAL.  WHEN .TRUE., THE Y LOWER BOUND IS
C             CONSTANT AND HAS VALUE YLB AND THE INPUT NAMED FUNYLB IS 
C             NEVER REFERENCED.  WHEN .FALSE., THE Y LOWER BOUND IS TO 
C             BE COMPUTED USING THE USER-SUPPLIED FUNCTION FUNYLB AND 
C             THE INPUT NAMED YLB IS NEVER REFERENCED.
C     YLB     CONSTANT LOWER BOUND FOR VARIABLE (Y) USED IN INNER
C             INTEGRAL WHEN YLBCON IS .TRUE.
C     FUNYLB  USER-SUPPLIED FUNCTION OF X, PARM1, PARM2, AND PARM3
C             WHICH COMPUTES THE LOWER BOUND FOR THE INNER INTEGRAL AT
C             EACH VALUE OF X IN THE RANGE XLB TO XUB.  USED ONLY WHEN
C             YLBCON IS .FALSE.
C     YUBCON  CONTROLS COMPUTATION OF UPPER BOUND FOR VARIABLE (Y) USED
C             IN INNER INTEGRAL.  WHEN .TRUE., THE Y UPPER BOUND IS
C             CONSTANT AND HAS VALUE YUB AND THE INPUT NAMED FUNYUB IS 
C             NEVER REFERENCED.  WHEN .FALSE., THE Y UPPER BOUND IS TO 
C             BE COMPUTED USING THE USER-SUPPLIED FUNCTION FUNYUB AND 
C             THE INPUT NAMED YUB IS NEVER REFERENCED.
C     YUB     CONSTANT UPPER BOUND FOR VARIABLE (Y) USED IN INNER
C             INTEGRAL WHEN YUBCON Is .TRUE.
C     FUNYUB  USER-SUPPLIED FUNCTION OF X, PARM1, PARM2, AND PARM3
C             WHICH COMPUTES THE UPPER BOUND FOR THE INNER INTEGRAL AT
C             EACH VALUE OF X IN THE RANGE XLB TO XUB.  USED ONLY WHEN
C             YUBCON IS .FALSE.
C     FUNXY   USER-SUPPLIED INTEGRAND FUNCTION OF X, Y, PARM1, PARM2, 
C             AND PARM3.
C     PARM1   PARAMETER VARIABLES OR ARRAYS WHICH ARE PASSED TO FUNYLB,
C     PARM2   FUNYUB, AND FUNXY.  THEY MAY BE USED OR NOT USED IN ANY
C     PARM3   COMBINATION BY ANY OF THE THREE FUNCTIONS AS REQUIRED BY
C             THE PARTICULAR APPLICATION.
C     ERRTOL  ALLOWED RELATIVE ERROR IN THE TOTAL INTEGRAL.
C     MAXCYC  MAXIMUM NUMBER OF ITERATIONS TO BE ATTEMPTED.
C   OUTPUT:
C     RESULT  THE VALUE COMPUTED FOR THE DOUBLE INTEGRATION.
C     ERREST  AN ESTIMATE OF THE RELATIVE ERROR IN RESULT.
C     IER     ERROR FLAG.  WHEN IER < 0, RESULT IS SET TO THE CLOBBER
C             CONSTANT.
C
      EXTERNAL FUNYLB, FUNYUB, FUNXY
      external dtmcon
      double precision dtmcon
      DOUBLE PRECISION XLB, XUB, YLB, FUNYLB, YUB, FUNYUB, FUNXY,
     +    PARM1, PARM2, PARM3, ERRTOL, RESULT, ERREST
      INTEGER MAXCYC, IER
      LOGICAL YLBCON, YUBCON
C
C   LOCAL VARIABLES
      DOUBLE PRECISION W4W8(6), Z4Z8(6), X(12), RSLT(12), EREST(12)
      DOUBLE PRECISION EPS, EPSSQR, SMALL, FTOL, YLBD, YUBD
      DOUBLE PRECISION XBEG, XMID, HX, DIRX, RSUMX, ESUMX, 
     +    HCPX, F1X, F2X, PX
      DOUBLE PRECISION YBEG, YMID, HY, DIRY, RSUMY, ESUMY, 
     +    HCPY, F1Y, F2Y, PY, RSLTY, ERRTY
      DOUBLE PRECISION TEMP, G4, G8, ABG, TE, RE, EW, ER, Q, Q16, 
     +    ABH, D1, D2, E8
      INTEGER MXCYC, NCNSCX, NCNSCY, NCYCX, NCYCY, I, J
      LOGICAL NEWSGX, FINSGX, NEWSGY, FINSGY, YFAIL1, YFAIL2
      CHARACTER*8 SUBNAM
C
      DATA SUBNAM /'DTDIGL'/
C     FOUR AND EIGHT POINT WEIGHTS (COMBINED)
      DATA W4W8 /.652145154862546D0,.347854845137454D0,
     +           .362683783378362D0,.313706645877887D0,
     +           .222381034453375D0,.101228536290376D0 /
C     FOUR AND EIGHT POINT ABSCISSAE (COMBINED)
      DATA Z4Z8 /.339981043584856D0,.861136311594053D0,
     +           .183434642495650D0,.525532409916329D0,
     +           .796666477413627D0,.960289856497536D0 /
C
C   INITIALIZATION
      MXCYC = MAXCYC
      IF (MAXCYC .LT. 1) MXCYC = 12
      YFAIL1 = .FALSE.
      YFAIL2 = .FALSE.
      IER = 0
      EPS = DTMCON(5)
      EPSSQR = EPS * EPS
      SMALL = 100.0D0 * DTMCON(4)
      FTOL = SQRT( 1.0D0 + ERRTOL) - 1.0D0
      FTOL = MAX (FTOL/200.0D0, EPS * 0.5D0)
C
C   INITIALIZATION FOR OUTER (X) INTEGRAL
      IF (YLBCON) YLBD = YLB
      IF (YUBCON) YUBD = YUB
      NCYCX = 0
      NCNSCX = 0
      RSUMX = 0.0D0
      ESUMX = 0.0D0
      NEWSGX = .TRUE.
      HCPX = 0.0D0
      F2X = 0.0D0
      DIRX = SIGN (1.0D0, XUB - XLB)
      IF (XLB .EQ. XUB) GO TO 300
      XBEG = XLB
C     TRY WHOLE RANGE IN ONE SEGMENT TO START
      HX = 0.5D0 * (XUB - XLB)
      FINSGX = .TRUE.
C
C   START LOOP FOR OUTER INTEGRAL (COMPUTE ONE SEGMENT)
  10  CONTINUE
      XMID = XBEG + HX
C     IS HX TOO SMALL TO BE SENSED RELATIVE TO XMID?
      TEMP = XMID + 0.1D0*HX
      IF (TEMP .EQ. XMID) GO TO 9804
      IF (NCYCX .GT. MXCYC) GO TO 9803
C
C   ESTABLISH X VALUES FOR 4- AND 8-POINT ESTIMATES FOR THIS SEGMENT
C     OF OUTER INTEGRAL
      J = 1
      DO 20 I=1,6
        TEMP = Z4Z8(I) * HX
        X(J)   = XMID + TEMP
        X(J+1) = XMID - TEMP
        J = J + 2
  20  CONTINUE
C
C   COMPUTE INNER INTEGRAL FOR THE 12 X VALUES CHOSEN IN THIS SEGMENT
      DO 100 I=1,12
C
C     INITIALIZE FOR INNER (Y) INTEGRAL
        IF (.NOT. YLBCON) YLBD = FUNYLB (X(I), PARM1, PARM2, PARM3)
        IF (.NOT. YUBCON) YUBD = FUNYUB (X(I), PARM1, PARM2, PARM3)
        NCYCY = 0
        NCNSCY = 0
        RSLTY = 0.0D0
        ERRTY = 1.0D0
        RSUMY = 0.0D0
        ESUMY = 0.0D0
        NEWSGY = .TRUE.
        HCPY = 0.0D0
        F2Y = 0.0D0
        DIRY = SIGN (1.0D0, YUBD - YLBD)
        IF (YLBD .EQ. YUBD) GO TO 90
        YBEG = YLBD
C       TRY WHOLE RANGE IN ONE SEGMENT TO START
        HY = 0.5D0 * (YUBD - YLBD)
        FINSGY = .TRUE.
C
C       START LOOP FOR INNER INTEGRAL (COMPUTE ONE SEGMENT)
  30      CONTINUE
          YMID = YBEG + HY
C         IS HY TOO SMALL TO BE SENSED RELATIVE TO YMID?
          TEMP = YMID + 0.1D0*HY
          IF (TEMP .EQ. YMID) THEN
            YFAIL2 = .TRUE.
            RSUMY = RSLTY
            ESUMY = ERRTY
            GO TO 90
          END IF
          IF (NCYCY .GT. MXCYC) THEN
            YFAIL1 = .TRUE.
            RSUMY = RSLTY
            ESUMY = ERRTY
            GO TO 90
          END IF
C
C       COMPUTE 4-POINT ESTIMATE
          G4 = 0.0D0
          DO 40 J=1,2
            TEMP = Z4Z8(J) * HY
            G4 = G4 + W4W8(J) * 
     +         (FUNXY (X(I), YMID-TEMP, PARM1, PARM2, PARM3) +
     +          FUNXY (X(I), YMID+TEMP, PARM1, PARM2, PARM3))
  40      CONTINUE
          G4 = G4 * HY
C
C       COMPUTE 8-POINT ESTIMATE
          G8 = 0.0D0
          DO 50 J=3,6
            TEMP = Z4Z8(J) * HY
            G8 = G8 + W4W8(J) * 
     +         (FUNXY (X(I), YMID-TEMP, PARM1, PARM2, PARM3) +
     +          FUNXY (X(I), YMID+TEMP, PARM1, PARM2, PARM3))
  50      CONTINUE
          G8 = G8 * HY
C
C       ESTIMATE ERROR IN INTEGRAL OF SEGMENT BY COMPARING 4-POINT
C         AND 8-POINT ESTIMATES
          ABH = ABS (HY)
          ABG = ABS (G8) + EPSSQR
          TE = ABS (G8 - G4) + EPS*ABG
C         RE IS THE RELATIVE ERROR IN THE SUBINTERVAL THE 4 PT. RESULT 
C           MAKES IF THE 8 PT. RESULT IS EXACT
          RE = TE/ABG + EPS
          ER = TE*RE + SMALL
          IF (NCYCY .EQ. 0) THEN
            PY = ABG
C           PY IS ROUGH UPPER BOUND TO ABSOLUTE VALUE OF INTEGRAL
            RSLTY = G8
            ERRTY = MAX (ER, EPS*ABG)
C           SAVE THE INITIAL ESTIMATES FOR WHOLE INNER INTEGRAL TO USE
C           IN CASE WE FAIL TO DO BETTER
          END IF
          NCYCY = NCYCY + 1
          EW = MAX (FTOL*PY, SMALL)
          Q = EW/ER
          Q16 = Q**.0625D0
          D1 = ABH*0.5D0/RE**.125D0
C         D1 IS THE ESTIMATE OF THE DISTANCE "A" TO THE SINGULARITY
          D2 = ABH/D1*Q16
C         D2 IS AN IMPORTANCE FACTOR WHICH NORMALLY RANGES FROM ABOUT 10.
C           TO 0.1 .  WHEN THE RESULT IS UNIMPORTANT, D2 IS LARGE.
C
C       THE MAGIC GO-GO OR NO-GO QUANTITY IS  100Q , FOUND AS FOLLOWS.
C         WE REQUIRE THAT THE RELATIVE ERROR IN THE 8 PT. SUBINTERVAL
C         VALUE  (RE**2) TIMES THE IMPORTANCE OF THE SUBINTEGRAL (ABG/P)
C         BE LESS THAN HALF THE REQUIRED TOLERANCE  FTOL .
C         ALTERNATIVELY, (FTOL/2)*(PY/ABG)/(RE**2)  MUST BE GREATER THAN 1.0
C         THE ABOVE EXPRESSION, WHEN MULTIPLIED OUT, IS 100Q.
C
          IF(Q.LE. 0.01D0) THEN
C           NOT GOOD ENOUGH.  TRY A SMALLER SEGMENT.
            IF (NEWSGY) THEN
C             WAS FIRST TRY FROM YBEG.  DO FIRST CUTBACK.
              F1Y = Q16
              ABH = MIN (0.75D0*ABH, D1*Q16)
            ELSE
C             DO SUBSEQUENT CUTBACK ON THIS SEGMENT
              F1Y = F1Y * Q16
              ABH = F1Y * ABH
            END IF
            NEWSGY = .FALSE.
            FINSGY = .FALSE.
            NCNSCY = 0
          ELSE
C           CURRENT ESTIMATE FOR THIS SEGMENT IS GOOD ENOUGH
            RSUMY = RSUMY + G8
            ESUMY = ESUMY + MAX (ER, EPS*ABG)
C
C           EXIT LOOP FOR INNER INTEGRAL WHEN THAT WAS FINAL SEGMENT
            IF (FINSGY) GO TO 90
C
C           ADVANCE TO NEXT SEGMENT
            YBEG = YBEG + 2.0D0*HY
            NEWSGY = .TRUE.
            NCNSCY = NCNSCY + 1
C           MODIFY SEGMENT WIDTH ACCORDING TO EXPERIENCE
            F2Y = 0.5D0 * F2Y
            IF (HCPY .GT. 0.0D0) F2Y = F2Y + LOG (ABH/HCPY)
            HCPY = ABH
            IF (NCNSCY .GT. 4 .OR. F2Y .GE. 0.0D0) THEN
C             SUCCESSFUL HISTORY
              ABH = D2 * (D1 + 2.0D0*ABH) * Q16
            ELSE
C             PAST FAILURES NOT FORGOTTEN YET
              ABH = D1 * D2 / (1.0D0 + 2.0D0*D2)
            END IF
            PY = MAX (PY, ABG)
            IF (ABS (YUBD - YBEG) .LE. 2.0D0*ABH) THEN
C             THIS WILL BE THE FINAL SEGMENT
              ABH = 0.5D0 * ABS (YUBD - YBEG)
              FINSGY = .TRUE.
            END IF
          END IF
          HY = DIRY * ABH
          GO TO 30
C       END LOOP FOR INNER INTEGRAL
C
  90    CONTINUE
        RSLT(I) = RSUMY
        EREST(I) = 2.0D0 * ESUMY / (ABS (RSUMY) + 10.0D0*DTMCON(4))
 100  CONTINUE
C   NOW HAVE THE VALUES FOR THE 4- AND 8-POINT ESTIMATES FOR A SEGMENT
C     OF THE OUTER INTEGRAL
      J = 1
      G4 = 0.0D0
      DO 110 I=1,2
        G4 = G4 + W4W8(I) * (RSLT(J) + RSLT(J+1))
        J = J + 2
 110  CONTINUE
      G4 = G4 * HX
      G8 = 0.0D0
      E8 = 0.0D0
      DO 120 I=3,6
        G8 = G8 + W4W8(I) * (RSLT(J) + RSLT(J+1))
        E8 = E8 + W4W8(I) * (EREST(J)*RSLT(J) + EREST(J+1)*RSLT(J+1))
        J = J + 2
 120  CONTINUE
      G8 = G8 * HX
      E8 = E8 * HX
C
C   ESTIMATE ERROR IN INTEGRAL OF SEGMENT BY COMPARING 4-POINT
C     AND 8-POINT ESTIMATES
      ABH = ABS (HX)
      ABG = ABS (G8) + EPSSQR
      TE = ABS (G8 - G4) + EPS*ABG
C     RE IS THE RELATIVE ERROR IN THE SUBINTERVAL THE 4 PT. RESULT 
C       MAKES IF THE 8 PT. RESULT IS EXACT
      RE = TE/ABG + EPS
      ER = TE*RE + SMALL
      IF (NCYCX .EQ. 0) THEN
        PX = ABG
C       PX IS ROUGH UPPER BOUND TO ABSOLUTE VALUE OF INTEGRAL
        RESULT = G8
        ERREST = E8 + MAX (ER, EPS*ABG)
C       SAVE THE INITIAL ESTIMATES FOR WHOLE INTEGRAL TO USE
C       IN CASE WE FAIL TO DO BETTER
      END IF
      NCYCX = NCYCX + 1
      EW = MAX (FTOL*PX, SMALL)
      Q = EW/ER
      Q16 = Q**.0625D0
      D1 = ABH*0.5D0/RE**.125D0
C     D1 IS THE ESTIMATE OF THE DISTANCE "A" TO THE SINGULARITY
      D2 = ABH/D1*Q16
C     D2 IS AN IMPORTANCE FACTOR WHICH NORMALLY RANGES FROM ABOUT 10.
C       TO 0.1 .  WHEN THE RESULT IS UNIMPORTANT, D2 IS LARGE.
C
C   THE MAGIC GO-GO OR NO-GO QUANTITY IS  100Q , FOUND AS FOLLOWS.
C     WE REQUIRE THAT THE RELATIVE ERROR IN THE 8 PT. SUBINTERVAL
C     VALUE  (RE**2) TIMES THE IMPORTANCE OF THE SUBINTEGRAL (ABG/P)
C     BE LESS THAN HALF THE REQUIRED TOLERANCE  FTOL .
C     ALTERNATIVELY, (FTOL/2)*(PX/ABG)/(RE**2)  MUST BE GREATER THAN 1.0
C     THE ABOVE EXPRESSION, WHEN MULTIPLIED OUT, IS 100Q.
C
      IF(Q.LE. 0.01D0) THEN
C       NOT GOOD ENOUGH.  TRY A SMALLER SEGMENT.
        IF (NEWSGX) THEN
C         WAS FIRST TRY FROM XBEG.  DO FIRST CUTBACK.
          F1X = Q16
          ABH = MIN (0.75D0*ABH, D1*Q16)
        ELSE
C         DO SUBSEQUENT CUTBACK ON THIS SEGMENT
          F1X = F1X * Q16
          ABH = F1X * ABH
        END IF
        NEWSGX = .FALSE.
        FINSGX = .FALSE.
        NCNSCX = 0
      ELSE
C       CURRENT ESTIMATE FOR THIS SEGMENT IS GOOD ENOUGH
        RSUMX = RSUMX + G8
        ESUMX = ESUMX + MAX (ER, EPS*ABG) + E8
C
C       EXIT LOOP FOR OUTER INTEGRAL WHEN THAT WAS FINAL SEGMENT
        IF (FINSGX) GO TO 300
C
C       ADVANCE TO NEXT SEGMENT
        XBEG = XBEG + 2.0D0*HX
        NEWSGX = .TRUE.
        NCNSCX = NCNSCX + 1
C       MODIFY SEGMENT WIDTH ACCORDING TO EXPERIENCE
        F2X = 0.5D0 * F2X
        IF (HCPX .GT. 0.0D0) F2X = F2X + LOG (ABH/HCPX)
        HCPX = ABH
        IF (NCNSCX .GT. 4 .OR. F2X .GE. 0.0D0) THEN
C         SUCCESSFUL HISTORY
          ABH = D2 * (D1 + 2.0D0*ABH) * Q16
        ELSE
C         PAST FAILURES NOT FORGOTTEN YET
          ABH = D1 * D2 / (1.0D0 + 2.0D0*D2)
        END IF
        PX = MAX (PX, ABG)
        IF (ABS (XUB - XBEG) .LE. 2.0D0*ABH) THEN
C         THIS IS THE FINAL SEGMENT
          ABH = 0.5D0 * ABS (XUB - XBEG)
          FINSGX = .TRUE.
        END IF
      END IF
      HX = DIRX * ABH
      GO TO 10
C   END LOOP FOR OUTER INTEGRAL
C
 300  CONTINUE
      ERREST = 2.0D0 * ESUMX / (ABS (RSUMX) + 10.0D0*DTMCON(4))
      RESULT = RSUMX
      IF (YFAIL1) GO TO 9801
      IF (YFAIL2) GO TO 9802
      RETURN
C
C   ERROR EXITS
C   MAX ITERATIONS EXCEEDED ON ONE OR MORE EVALUATIONS OF INNER INTEGRAL
 9801 IER = 1
      IF (YFAIL2) CALL DTERR (0, SUBNAM, 2, 0)
      GO TO 9900
C   FORCED TO TOO SMALL A STEP ON ONE OR MORE EVALUATIONS OF INNER INTEGRAL
 9802 IER = 2
      GO TO 9900
C   MAX NUMBER OF ITERATIONS EXCEEDED ON OUTER INTEGRAL
 9803 IER = 3
      GO TO 9900
C   FORCED TO GO TO TOO SMALL AN INTERVAL ON OUTER INTEGRAL
 9804 IER = 4
C   COMMON EXIT
 9900 CONTINUE
      CALL DTERR (0, SUBNAM, IER, 0)
      RETURN
      END
