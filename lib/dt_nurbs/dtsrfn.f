      SUBROUTINE DTSRFN(X,INCX,C,WORK,NWORK,VNORM,CROSS,IER)
C
C #### ROBUST VERSION HANDLES FIRST-ORDER DEGENERACIES ####
C
C  PURPOSE: COMPUTE A UNIT NORMAL VECTOR TO A SPLINE SURFACE.
C
C  METHOD: TAKES CROSS PRODUCT OF THE TWO FIRST-ORDER PARTIALS.
C          ORIENTATION IS DEFINED BY THE ORDER OF THE CROSS PRODUCT.
C          NO ATTEMPT TO MAKE NORMAL POINT "INTO" OR "OUT OF"
C          A CLOSED SURFACE.
C
C  USAGE:  INTEGER INCX,NWORK,IER
C          DOUBLE PRECISION X(INCX,*),C(*),WORK(NWORK),VNORM(3),CROSS
C          CALL DTSRFN(X,INCX,C,WORK,NWORK,VNORM,CROSS,IER)
C
C  INPUTS:  X     = ARRAY OF LENGTH 2 CONTAINING PARAMETER VALUES
C                   AT WHICH TO EVALUATE THE SURFACE
C           INCX  = INCREMENT PARAMETER FOR THE ARRAY X.
C                   THE SURFACE PARAMETERS ARE IN X(1) AND X(1+INCX).
C           C     = SPLINE DEFINITION ARRAY FOR A 3D SURFACE
C           
C  WORKING  WORK  = DOUBLE PRECISION WORK ARRAY OF LENGTH NWORK.
C  STORAGE  NWORK = TRUE LENGTH OF WORK ARRAY,
C                   NWORK .GE. 5*KMAX**2 + 3*KMAX +16, 
C                     WHERE KMAX = MAX(C(3),C(4))
C                                = MAXIMUM SPLINE ORDER.
C                              
C  OUTPUT:  VNORM = 3D VECTOR WHICH IS A UNIT NORMAL TO 
C                   THE SURFACE AT THE POINT X,
C                   OR ZERO, IF THE SURFACE IS DEGENERATE THERE
C           CROSS = SQUARE MAGNITUDE OF THE CROSS PRODUCT OF
C                   THE TWO PARAMETRIC FIRST DERIVATIVES AT UV,
C                   WHICH IS THE (SQUARED) LENGTH OF VNORM
C                   BEFORE NORMALIZING,
C                   OR ZERO IF THE SURFACE IS DEGENERATE AT X.
C
C           IER   = SUCCESSS / ERROR FLAG
C                     0 => SUCCESS; UV IS NOT A SINGULAR POINT
C                    +1 => SURFACE IS SINGULAR AT UV,
C                          BUT ONLY TO FIRST ORDER.
C                          A CONSISTENT NORMAL VECTOR HAS BEEN FOUND.
C                   -61 => C VECTOR IS NOT A 3D SURFACE.
C                   -62 => SURFACE IS SINGULAR AT UV, 
C                          AND NO NORMAL VECTOR COULD BE COMPUTED.
C
C                   OTHERWISE, AN ERROR RETURN FROM DTNPDR, Q.V.
C
C  SUBROUTINES CALLED:  DTMCON  DTNPDR 
C
C  DATE:  6-JUL-89
C
C
C  PARAMETERS
C
      INTEGER INCX,NWORK,IER
      DOUBLE PRECISION C(*), X(INCX,2), VNORM(3), CROSS
      DOUBLE PRECISION WORK(*)
C
C  INTERNAL VARIABLES
C
      DOUBLE PRECISION DTMCON
      EXTERNAL DTMCON
      DOUBLE PRECISION DU(4), DV(4), ANORM
      DOUBLE PRECISION DUU(4), DUV(4), DVV(4)
      DOUBLE PRECISION BNORM(3), ANSQR, BNSQR, CNSQR, EPS
      INTEGER ID(6), MODE, NEED
      CHARACTER*8 SUBNAM
      DATA SUBNAM / 'DTSRFN' /
      DATA ID / 0, 1, 1, 0, 2, 0 /
C
C  ERROR CHECK
C
      IF(C(1) .NE. 2.0 .OR. 
     *   C(2) .NE. 3.0 .AND. C(2) .NE. -4.0) THEN
        IER = -61
        GO TO 9100
      ENDIF
C
C  USUAL CASE:  COMPUTATIONS AT NON-SINGULAR POINTS
C               REQUIRE FIRST PARTIALS ONLY,
C               CROSS PRODUCT DONE IN-LINE.
C
      CALL DTNPDR(X,INCX,ID(3),C,WORK,NWORK,DU,IER)
      IF(IER .LT. 0) GO TO 9400
      CALL DTNPDR(X,INCX,ID(1),C,WORK,NWORK,DV,IER)
      IF(IER .LT. 0) GO TO 9400
      VNORM(1) = DU(2)*DV(3) - DU(3)*DV(2)
      VNORM(2) = DU(3)*DV(1) - DU(1)*DV(3)
      VNORM(3) = DU(1)*DV(2) - DU(2)*DV(1)
      CROSS = VNORM(1)**2 + VNORM(2)**2 + VNORM(3)**2
C
C  ROBUST NORMAL COMPUATIONS AT A FIRST-ORDER SINGULARITY
C  REQUIRE EVALUATING SECOND-ORDER PARTIALS
C
      ANSQR = DU(1)**2 + DU(2)**2 + DU(3)**2
      BNSQR = DV(1)**2 + DV(2)**2 + DV(3)**2
      IF(CROSS .GT. EPS * ANSQR * BNSQR) THEN
        ANORM = CROSS
      ELSE
        EPS = 8D0*DTMCON(6) 
        CALL DTNPDR(X,INCX,ID(5),C,WORK,NWORK,DUU,IER)
        IF(IER .LT. 0) GO TO 9400
        CALL DTNPDR(X,INCX,ID(2),C,WORK,NWORK,DUV,IER)
        IF(IER .LT. 0) GO TO 9400
        CALL DTNPDR(X,INCX,ID(4),C,WORK,NWORK,DVV,IER)
        IF(IER .LT. 0) GO TO 9400
C
C  COMPUTE (DU X DUV + DUU X DV) IN VNORM(*).
C
        VNORM(1) = DU (2) * DUV(3) - DU (3) * DUV(2)
     *           + DUU(2) * DV (3) - DUU(3) * DV (2)
        VNORM(2) = DU (3) * DUV(1) - DU (1) * DUV(3)
     *           + DUU(3) * DV (1) - DUU(1) * DV (3)
        VNORM(3) = DU (1) * DUV(2) - DU (2) * DUV(1)
     *           + DUU(1) * DV (2) - DUU(2) * DV (1)
C
C  OTHER POSSIBLE DIRECTION IS (DUV X DV + DU X DVV).
C  LEAVE THIS IN BNORM(*).
C
        BNORM(1) = DUV(2) * DV (3) - DUV(3) * DV (2)
     *           + DU (2) * DVV(3) - DU (3) * DVV(2)
        BNORM(2) = DUV(3) * DV (1) - DUV(1) * DV (3)
     *           + DU (3) * DVV(1) - DU (1) * DVV(3)
        BNORM(3) = DUV(1) * DV (2) - DUV(2) * DV (1)
     *           + DU (1) * DVV(2) - DU (2) * DVV(1)
C
C  IF THESE TWO DIRECTIONS ARE ESSENTIALLY PARALLEL,
C  THEY DETERMINE A WELL-DEFINED NORMAL VECTOR 
C  IN THE LIMIT AS WE APPROACH THE TEST POINT.
C
        ANSQR = VNORM(1)**2 + VNORM(2)**2 + VNORM(3)**2
        BNSQR = BNORM(1)**2 + BNORM(2)**2 + BNORM(3)**2
        CNSQR = (VNORM(2)*BNORM(3)-VNORM(3)*BNORM(2))**2
     *        + (VNORM(3)*BNORM(1)-VNORM(1)*BNORM(3))**2
     *        + (VNORM(1)*BNORM(2)-VNORM(2)*BNORM(1))**2
        IF(CNSQR .GT. EPS * ANSQR * BNSQR) THEN
          IER = -62
          GO TO 9300
        ENDIF
C
C  ENHANCE STABILITY BY USING THE VECTOR OF LARGER NORM.
C
        ANORM = ANSQR
        IF(BNSQR .GT. ANSQR) THEN
          ANORM    = BNSQR
          VNORM(1) = BNORM(1)
          VNORM(2) = BNORM(2)
          VNORM(3) = BNORM(3)
        ENDIF
        IER = +1
      ENDIF
C
C  NORMALIZE VNORM(*) TO UNIT LENGTH
C
      IF(ANORM .EQ. 0D0) THEN
        IER = -62
        GO TO 9300
      ENDIF
      ANORM = 1.D0 / SQRT(ANORM)
      VNORM(1) = VNORM(1) * ANORM
      VNORM(2) = VNORM(2) * ANORM
      VNORM(3) = VNORM(3) * ANORM
C
C  NORMAL EXIT
C
      RETURN
C
C  ERROR EXITS
C
 9100 CONTINUE
      MODE = 1
      GO TO 9900
 9300 CONTINUE
      MODE = 3
      GO TO 9900
 9400 CONTINUE
      MODE = 4
 9900 CONTINUE
      CALL DTERR(MODE,SUBNAM,IER,NEED)
      VNORM(1) = DTMCON(1)
      RETURN
C
      END
