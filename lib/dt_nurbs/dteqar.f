C***** DTEQAR *****
C   EXTRACT POINTS AT EQUAL ARC LENGTH
C     LOCATE INTERNAL POINTS WHICH DELIMIT THE SPECIFIED NUMBER OF CURVE 
C     SEGMENTS SO THAT THE SEGMENTS HAVE EQUAL ARC LENGTHS ALONG A 
C     (RATIONAL) SPLINE CURVE.
C
C   INPUT:
C     C       DTRC SPLINE ARRAY.
C     NSEG    NUMBER OF SEGMENTS TO DIVIDE THE CURVE INTO. 
C     EPS     DESIRED ABSOLUTE ACCURACY SOUGHT FOR THE SEGMENT ARC LENGTHS.
C     MAXITN  MAXIMUM NUMBER OF LOOP ITERATIONS
C     MDIM    DIMENSION OF T ARRAY AND FIRST DIMENSION OF V ARRAY
C   WORKSPACE:
C     WORK    WORKING ARRAY OF DIMENSION NWORK
C     NWORK   LENGTH OF THE ARRAY WORK, NWORK .GE. C(3)**2 + C(3)*4 + C(4)
C   OUTPUT:
C     T       ARRAY CONTAINING THE PARAMETER VALUES OF THE DIVISION POINTS, 
C             INCLUDING THE END POINTS.
C     V       ARRAY CONTAINING THE POINTS ON THE CURVE CORRESPONDING TO THE
C             PARAMETER VALUES IN T.
C     IER     SUCCESS/ERROR CODE. 
C
C   CALLS:
C     DTEQA1 (AS INTEGRAND FUNCTION FOR CALLS TO DTQUAD)
C     DTGET
C     DTMCON
C     DTQUAD
C     DTSPVL
C
      SUBROUTINE DTEQAR (C, NSEG, EPS, MAXITN, MDIM, WORK, NWORK, 
     +    T, V, IER)
      INTEGER NSEG, MAXITN, MDIM, NWORK, IER
      DOUBLE PRECISION C(*), EPS, WORK(NWORK), T(MDIM), V(MDIM,*)
C
C   LOCAL VARIABLES:
      DOUBLE PRECISION PLO, PHI, RELERR, SEGLEN, TOTLEN, EPS2, EPSMIN,
     +    TLO, THI, TNX, SLO, SHI, SNX, STGT, TOTERR, ERREST, VTMP(4),
     +    ONEMEP
      INTEGER N, MRAW, M, K, NCOEF, NWK, IWK, ICK, ITN, ISEG, I, MODE
      LOGICAL OVRMAX
      CHARACTER*8 SUBNAM
C
      EXTERNAL DTEQA1
      DOUBLE PRECISION DTEQA1, DTMCON
C
      DATA SUBNAM /'DTEQAR'/
C
C   INITIALIZE AND GET SPLINE PARAMETERS
      ONEMEP = 1.0D0 - DTMCON(6)
      IER = 0
      MODE = 1
      EPSMIN = 1.0D2 * DTMCON(5)
      OVRMAX = .FALSE.
      IF (NSEG .LT. 1) GO TO 9007
      IF (NSEG+1 .GT. MDIM) GO TO 9008
      CALL DTGET (C, .TRUE., 1, N, MRAW, M, K, NCOEF, PLO, PHI, IER)
      IF (IER .NE. 0) GO TO 9900
      IF (N .NE. 1)  GO TO 9001
      IF (ABS(MRAW) .GT. 4) GO TO 9002
      IF (K*(K+4)+NCOEF .GT. NWORK) GO TO 9006
C   DO LEFT END POINT
      T(1) = PLO
      CALL DTSPVL (PLO, C, WORK, NWORK, VTMP, IER)
      IF (IER .NE. 0) GO TO 9099
      DO 10 I=1,M
        V(1,I) = VTMP(I)
   10 CONTINUE
C   DO RIGHT END POINT AND GATHER DATA FOR ROUGH LENGTH ESTIMATE
      T(NSEG+1) = PHI
      CALL DTSPVL (PHI, C, WORK, NWORK, VTMP, IER)
      IF (IER .NE. 0) GO TO 9099
      TOTLEN = 0.0D0
      DO 20 I=1,M
        V(NSEG+1,I) = VTMP(I)
        TOTLEN = TOTLEN + (V(1,I) - VTMP(I))**2
   20 CONTINUE
      IF (NSEG .EQ. 1) RETURN
C   MAKE ARBITRARY GUESSTIMATE OF TOTAL LENGTH
      TOTLEN = MAX (5*(PHI - PLO), 2*SQRT(TOTLEN))
      EPS2 = MAX (0.5D0*EPS, EPSMIN)
      RELERR = MAX (MIN (EPS2/TOTLEN, 0.1D0), EPSMIN)
      TOTERR = 0.0D0
      TOTLEN = 0.0D0
      NWK = 0
      TLO = PLO
C   FIND SMOOTH SPLINE INTERVALS AND THEIR LENGTHS
      DO 30 I=6+K,6+NCOEF
        IF (TLO .LT. C(I) .AND. C(I) .EQ. C(I+K-2)) THEN
          NWK = NWK + 2
          THI = ONEMEP*C(I)
          CALL DTQUAD (DTEQA1, C, TLO, THI, RELERR, 0, MAXITN, SEGLEN, 
     +        ICK, WORK(NWK+1), NWORK-NWK, ERREST, IER)
          IF (IER .NE. 0) GO TO 9099
          TOTERR = TOTERR + ERREST*SEGLEN
          TOTLEN = TOTLEN + SEGLEN
          WORK(NWK-1) = C(I)
          WORK(NWK) = TOTLEN
          TLO = C(I)
        END IF
   30 CONTINUE
      IF (TOTERR .GT. EPS2 .AND. RELERR .GT. EPSMIN) THEN
C       FIRST PASS NOT SUFFICIENTLY ACCURATE, REDO LENGTHS
        RELERR = MAX (EPS2/(TOTLEN+ERREST), EPSMIN)
        TOTERR = 0.0D0
        TOTLEN = 0.0D0
        TLO = PLO
        DO 40 I=2,NWK,2
          THI = ONEMEP*WORK(I-1)
          CALL DTQUAD (DTEQA1, C, TLO, THI, RELERR, 0, MAXITN, SEGLEN, 
     +        ICK, WORK(NWK+1), NWORK-NWK, ERREST, IER)
          IF (IER .NE. 0) GO TO 9099
          TOTERR = TOTERR + ERREST*SEGLEN
          TOTLEN = TOTLEN + SEGLEN
          WORK(NWK) = TOTLEN
          TLO = WORK(I-1)
   40   CONTINUE
      END IF
C   LOOP THROUGH REQUIRED DIVISION POINTS
      IWK = 2
      DO 200 ISEG = 2,NSEG
        STGT = (DBLE(ISEG-1) * TOTLEN) / DBLE(NSEG)
C       START LOOP (LOCATE PROPER SMOOTH SEGMENT OF CURVE)
   50     CONTINUE
          IF (STGT .LE. WORK(IWK)) GO TO 60
          IWK = IWK + 2
          IF (IWK .LE. NWK) GO TO 50
C       END LOOP (LOCATE SMOOTH SEGMENT CONTAINING DIVISION POINT)
C       SHOULD NEVER EXIT LOOP HERE
        GO TO 9009
   60   CONTINUE
        IF (IWK .EQ. 2) THEN
          TLO = PLO
          SLO = 0.0D0
        ELSE
          TLO = WORK(IWK-3)
          SLO = WORK(IWK-2)
        END IF
        THI = WORK(IWK-1)
        SHI = WORK(IWK)
        ITN = 1
C       START LOOP (SUCCESSIVE LINEAR INTERPOLATION WITHIN SEGMENT)
  100     CONTINUE
          TNX = (THI*(STGT-SLO) + TLO*(SHI-STGT))/(SHI - SLO)
          IF (STGT-SLO .LE. SHI-STGT) THEN
            CALL DTQUAD (DTEQA1, C, TLO, TNX, RELERR, 0, MAXITN, SEGLEN,
     +          ICK, WORK(NWK+1), NWORK-NWK, ERREST, IER)
            IF (IER .NE. 0) GO TO 9099
            SNX = SLO + SEGLEN
          ELSE
            CALL DTQUAD (DTEQA1, C, TNX, THI, RELERR, 0, MAXITN, SEGLEN,
     +          ICK, WORK(NWK+1), NWORK-NWK, ERREST, IER)
            IF (IER .NE. 0) GO TO 9099
            SNX = SHI - SEGLEN
          END IF
          IF (ABS (STGT-SNX) .LE. EPS2) GO TO 180
          IF (SNX .LT. STGT) THEN
            SLO = SNX
            TLO = TNX
          ELSE
            SHI = SNX
            THI = TNX
          END IF
          ITN = ITN + 1
          IF (ITN .LE. MAXITN) GO TO 100
C       END LOOP (INTERPOLATE IN SEGMENT)
        OVRMAX = .TRUE.
C       RECORD NEXT DIVISION POINT
  180   CONTINUE
        T(ISEG) = TNX
        CALL DTSPVL (TNX, C, WORK(NWK+1), NWORK-NWK, VTMP, IER)
        IF (IER .NE. 0) GO TO 9099
        DO 190 I=1,M
          V(ISEG,I) = VTMP(I)
  190   CONTINUE
  200 CONTINUE
C   END LOOP (NEXT DIVISION POINT)
C
      IF (OVRMAX) GO TO 9801
      IF (2.0D0*TOTERR .GT. EPS) GO TO 9802
C     NORMAL RETURN
      RETURN
C
C   ERROR EXITS
C   NOT A CURVE
 9001 IER = -1
      GO TO 9900
C   TOO MANY DEPENDENT VARIABLES (INCREASE VTMP AND VV DIMENSIONS)
 9002 IER = -2
      GO TO 9900
C   NOT ENOUGH WORKSPACE
 9006 IER = -6
      CALL DTERR (2, SUBNAM, IER, K*(K+4)+NCOEF)
      RETURN
C   LESS THAN ONE SEGMENT REQUESTED
 9007 IER = -7
      GO TO 9900
C   OUTPUT ARRAYS TOO SMALL
 9008 IER = -8
      GO TO 9900
C   INTERNAL LOOP CHECK FAILED
 9009 IER = -9
      GO TO 9900
C   ERROR DETECTED IN CALLED SUBROUTINE
 9099 IER = -99
      MODE = 4
      GO TO 9900
C
C   ACCURACY WARNING EXITS
C   EXCEEDED MAXITN AT ONE OR MORE DIVISION POINTS
 9801 IER = 1
      MODE = 0
      GO TO 9900
C   FAILED TO ACHIEVE REQUESTED ACCURACY
 9802 IER = 2
      MODE = 0
      GO TO 9900
C
C   COMMON ERROR MESSAGE
 9900 CONTINUE
      CALL DTERR (MODE, SUBNAM, IER, 0)
      RETURN
      END
C
C
C***** DTEQA1 *****
C   INTEGRAND FUNCTION FOR ARC LENGTH
C     USED AS FIRST ARGUMENT TO DTQUAD BY DTEQAR
C
      DOUBLE PRECISION FUNCTION DTEQA1 (X, CC, WORK, NWORK)
      INTEGER NWORK
      DOUBLE PRECISION X, CC(*), WORK(NWORK), VV(4, 0:1)
C
      M = CC(2)
      IF (M .LT. 0) M = -M - 1
      CALL DTSPDR( X, 1, CC, WORK, NWORK, VV, 4, IER)
      DTEQA1 = 0.0D0
      DO 10 I = 1, M
        DTEQA1 = DTEQA1 + VV(I,1)**2
10    CONTINUE
      DTEQA1 = SQRT (DTEQA1)
      RETURN
      END
